<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[无问西东]]></title>
    <url>%2F2018%2F12%2F19%2F%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C%2F</url>
    <content type="text"><![CDATA[就奋身做个英雄，不枉那青春勇。 愿心之自由共天地俊秀，有情有梦。 王菲&lt;无问西东&gt; 如果提前了解你们要面对的人生，不知你们是否还会有勇气前来。 看见的听到的，经常会令你们沮丧。世俗是这样强大，强大到生不出改变他们的念头来。 可是如果有机会提前了解了你们的人生，知道青春也不过只有这些日子，不知你们是否还会在意那些世俗让你们在意的事情，比如占有多少，才更荣耀，拥有什么，才能被爱。 等你们长大，你们会因绿芽冒出土地而喜悦，会对初升的朝阳欢呼跳跃，也会给别人善意和温暖，但是却会在赞美别的生命的同时，常常、甚至永远忘了自己的珍贵。 愿你在被打击时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵。 爱你所爱，行你所行，听从你心，无问西东。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>movie</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle(五)]]></title>
    <url>%2F2018%2F12%2F18%2FOracle(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[我见过太多善变的风景，差不多绝美或冷清。 刘昊霖-&lt;淤青&gt; 一、存储函数 存储函数又称为自定义函数。可以接收一个或多个参数，返回一个结果。在函数中我们可以使用 P/SQL 进行逻辑的处理。 12345678910111213141516171819202122232425--语法:CREATE [ OR REPLACE ] FUNCTION 函数名称（参数名称 参数类型, 参数名称 参数类型, ...）RETURN 结果变量数据类型IS变量声明部分;BEGIN逻辑部分;RETURN 结果变量;[EXCEPTION异常处理部分]END;--案例: 创建存储函数，根据地址 ID 查询地址名称。create function fn_getaddress(v_id number)return varchar2is v_name varchar2(30);begin select name into v_name from t_address where id=v_id; return v_name;end; --测试1select fn_getaddress(3) from dual;--测试2: 查询业主 ID，业主名称，业主地址，业主地址使用刚才我们创建的函数来实现。select id 编号,name 业主名称,fn_getaddress(addressid) 地址 from t_owners; 二、存储过程 存储过程是被命名的 PL/SQL 块，存储于数据库中，是数据库对象的一种。应用程序可以调用存储过程，执行相应的逻辑。 存储过程与存储函数都可以封装一定的业务逻辑并返回结果，存在区别如下：​ 1、 存储函数中有返回值，且必须返回；而存储过程没有返回值，可以通过​ 传出参数返回多个值。​ 2、 存储函数可以在 select 语句中直接使用，而存储过程不能。过程多数是​ 被应用程序所调用。​ 3、 存储函数一般都是封装一个查询结果，而存储过程一般都封装一段事务代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114--语法:CREATE [ OR REPLACE ] PROCEDURE 存储过程名称（参数名 类型, 参数名 类型, 参数名 类型）IS|AS 变量声明部分;BEGIN 逻辑部分[EXCEPTION 异常处理部分]END;--参数只指定类型，不指定长度--过程参数的三种模式：--IN 传入参数（默认）--OUT 传出参数 ，主要用于返回程序运行结果--IN OUT 传入传出参数--创建不带传出参数的存储过程create or replace procedure mypro1 as --这里可以声明变量begin dbms_output.put_line('存储过程调用了');end;--调用 execute mypro1; --创建带in和out参数，参数个数不限制create or replace procedure pro_getaddress(v_id number, v_address out varchar2) asbegin select name into v_address from t_address where id=v_id;end;-- plsql调用存储过程： execute mypro1;---对于无参数存储过程可以这样调用 或者 call mypro1 ---对于只有in 参数也可以这样调用 或者 declare ---此处声明一个变量用于接收out参数输出 v_address varchar2(30); begin pro_getaddress(1,v_address); DBMS_OUTPUT.put_line('地址：'||v_address); end; --jdbc调用含参的存储函数和存储过程： public String callProGetAddress(Long id) &#123; String addressName = null; Connection connection = DbUtils.getConnection(); CallableStatement callableStatement = null; try &#123; callableStatement = connection.prepareCall("&#123;call pro_getaddress(?,?)&#125;"); callableStatement.setLong(1, id); //注册传出参数类型 callableStatement.registerOutParameter(2, OracleTypes.VARCHAR); //执行存储过程 callableStatement.execute(); //获取传出参数赋值后的结果 addressName = callableStatement.getString(2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; DbUtils.closeAll(connection, callableStatement, null); &#125; return addressName; &#125; --案例:添加业主信息(不带传出参数的存储过程)--增加业主信息序列create sequence seq_owners start with 11;--增加业主信息存储过程create or replace procedure pro_owners_add( v_name varchar2, v_addressid number, v_housenumber varchar2, v_watermeter varchar2, v_type number)isbegin insert into T_OWNERS values( seq_owners.nextval,v_name,v_addressid, v_housenumber,v_watermeter,sysdate,v_type );commit;end;--调用call pro_owners_add('赵伟',1,'999-3','132-7',1);--JDBC 调用存储过程/*** 增加* @param owners*/public static void add(Owners owners)&#123;java.sql.Connection conn=null;java.sql.CallableStatement stmt=null;try &#123; conn=BaseDao.getConnection(); stmt=conn.prepareCall("&#123;call pro_owners_add(?,?,?,?,?)&#125;"); stmt.setString(1, owners.getName()); stmt.setLong(2, owners.getAddressid()); stmt.setString(3, owners.getHousenumber()); stmt.setString(4, owners.getWatermeter()); stmt.setLong(5, owners.getOwnertypeid()); stmt.execute();&#125; catch (SQLException e) &#123; e.printStackTrace();&#125;finally &#123; BaseDao.closeAll(null, stmt, conn);&#125;&#125; 三、触发器 数据库触发器是一个与表相关联的、存储的 PL/SQL 程序。每当一个特定的 数据操作语句(Insert,update,delete)在指定的表上发出时，Oracle 自动地执行触发 器中定义的语句序列。 触发器可用于:  数据确认  实施复杂的安全性检查  做审计，跟踪表上所做的数据操作等  数据的备份和同步 ​ 触发器分类:  前置触发器（BEFORE）  后置触发器（AFTER） 123456789101112--语法:CREATE [or REPLACE] TRIGGER 触发器名 BEFORE | AFTER [DELETE ][[or] INSERT] [[or]UPDATE [OF 列名]] ON 表名 [FOR EACH ROW ][WHEN(条件) ]declare ……begin PLSQL 块End ；--FOR EACH ROW 作用是标注此触发器是行级触发器,未标注是语句级触发器. 12345678910111213141516171819202122232425262728293031323334353637--前置触发器案例:--当用户输入本月累计表数后，自动计算出本月使用数.create or replace trigger tri_account_updatenum1beforeupdate of num1 on t_accountfor each rowdeclarebegin :new.usenum:=:new.num1-:new.num0;end;--后置触发器案例:--当用户修改了业主信息表的数据时记录修改前与修改后的值--创建业主名称修改日志表:用于记录业主更改前后的名称create table t_owners_log( updatetime date, ownerid number, oldname varchar2(30), newname varchar2(30));--创建后置触发器，自动记录业主更改前后日志create trigger tri_owners_logafter update of name on t_ownersfor each rowdeclarebegin insert into t_owners_log values(sysdate,:old.id,:old.name,:new.name);end;--测试--更新数据update t_owners set name='杨小花' where id=3;commit;--查询日志表select * from t_owners_log; 1234567891011121314151617181920212223242526272829303132333435--触发器应用一/*实施复杂的安全性检查：禁止在非工作时间插入新员工非工作时间周末：to_char(sysdate,'day') in ('星期六','星期日')上班前 下班后：to_number(to_char(sysdate,'hh24')) not between 9 and 17*/create or replace trigger securityempbefore inserton empbegin if to_char(sysdate,'day') in ('星期六','星期日') or to_number(to_char(sysdate,'hh24')) not between 9 and 17 then --禁止insert raise_application_error(-20001,'禁止在非工作时间插入新员工'); end if;end;--触发器应用二/*数据的确认：涨后的工资不能少于涨前的工资*/create or replace trigger checksalarybefore updateon empfor each row begin --if 涨后的薪水 &lt; 涨前的薪水 then if :new.sal &lt; :old.sal then raise_application_error(-20002,'涨后的工资不能少于涨前的工资.涨后:'||:new.sal||' 涨前:'||:old.sal); end if;end;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle(四)-PL/SQL语法]]></title>
    <url>%2F2018%2F12%2F18%2FOracle(%E5%9B%9B)PL-SQL%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[人生里看似偶然却又必经的告别，无约而至，无人可免。 许嵩-&lt;如约而至&gt; 一、PL/SQL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114[declare--声明变量]begin--代码逻辑[exception--异常处理]end;--声明变量变量名 类型(长度);--变量赋值变量名:=变量值--案例--声明变量水费单价、水费字数、吨数、金额。--对水费单价、字数、进行赋值 。吨数根据水费字数换算，规则为水费字数除以--1000，并且四舍五入，保留两位小数。计算金额，金额=单价*吨数。--输出单价 、数量和金额--变量的用法--set serveroutput on;--开启输出declarev_price number(10,2);--水费单价v_usenum number; --水费字数v_usenum2 number(10,2);--吨数v_money number(10,2);--金额beginv_price:=2.45;--水费单价v_usenum:=8012;--字数--字数换算为吨数v_usenum2:= round( v_usenum/1000,2);--计算金额v_money:=round(v_price*v_usenum2,2);--输出dbms_output.put_line('单价：'||v_price||'吨数:'||v_usenum2||'金额：'||v_money);end;--Select into 方式 赋值 (注意:结果必须是一条记录 ，有多条记录和没有记录都会报错)select 列名 into 变量名 from 表名 where 条件--开启输出set serveroutput ondeclare v_price number(10,2);--单价 v_usenum number;--水费字数 v_num0 number;--上月字数 v_num1 number;--本月字数 v_usenum2 number(10,2);--使用吨数 v_money number(10,2);--水费金额begin --对单价进行赋值 v_price:=3.45; --变量赋值 select usenum,num0,num1 into v_usenum,v_num0,v_num1 from t_account where year='2012' and month='01' and owneruuid=1; --使用吨数 v_usenum2:=round(v_usenum/1000,2); --计算金额 v_money:=v_price*v_usenum2; --输出 DBMS_OUTPUT.put_line('单价:'||v_price||'吨数:'||v_usenum2||'金额:'||v_money|| '上月字数:'||v_num0||'本月字数'||v_num1);end; --属性类型--%type 引用型: 引用某表某列的字段类型--开启输出set serveroutput ondeclare v_price number(10,2);--单价 v_usenum t_account.usenum%type;--水费字数 v_num0 t_account.num0%type;--上月字数 v_num1 t_account.num1%type;--本月字数 v_usenum2 number(10,2);--使用吨数 v_money number(10,2);--水费金额begin --对单价进行赋值 v_price:=3.45; --变量赋值 select usenum,num0,num1 into v_usenum,v_num0,v_num1 from t_account where year='2012' and month='01' and owneruuid=1; --使用吨数 v_usenum2:=round(v_usenum/1000,2); --计算金额 v_money:=v_price*v_usenum2; --输出 DBMS_OUTPUT.put_line('单价:'||v_price||'吨数:'||v_usenum2||'金额:'||v_money|| '上月字数:'||v_num0||'本月字数'||v_num1);end; --%rowtype 记录型: 标识某个表的行记录类型.--开启输出set serveroutput ondeclare v_price number(10,2);--单价 v_account t_account%rowtype;--记录型 v_usenum2 number(10,2);--使用吨数 v_money number(10,2);--水费金额begin --对单价进行赋值 v_price:=3.45; --变量赋值 select * into v_account from t_account where year='2012' and month='01' and owneruuid=1; --使用吨数 v_usenum2:=round(v_account.usenum/1000,2); --计算金额 v_money:=v_price*v_usenum2; --输出 DBMS_OUTPUT.put_line('单价:'||v_price||'吨数:'||v_usenum2||'金额:'||v_money|| '上月字数:'||v_account.num0||'本月字数'||v_account.num1);end; A、异常123456789101112131415--异常--预定义异常 - 当 PL/SQL 程序违反 Oracle 规则或超越系统限制时隐式引发--用户定义异常 - 用户可以在 PL/SQL 块的声明部分定义异常，自定义的异常通过 RAISE 语句显式引发--语法:exceptionwhen 异常类型 then异常处理逻辑--变量的用法----上面的案例后面(end;之前)加exceptionwhen NO_DATA_FOUND then dbms_output.put_line('未找到数据，请核实');when TOO_MANY_ROWS then dbms_output.put_line('查询条件有误，返回多条信息，请核实');end; B、条件判断1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556--语法1if 条件 then 业务逻辑end if;--语法2if 条件 then 业务逻辑else 业务逻辑end if;--语法3if 条件 then 业务逻辑elsif 条件 then 业务逻辑else 业务逻辑end if;--设置三个等级的水费 5 吨以下 2.45 元/吨 5 吨到 10 吨部分 3.45 元/吨 ，--超过 10 吨部分 4.45 ，根据使用水费的量来计算阶梯水费。--开启输出set serveroutput ondeclare v_price1 number(10,2);--不足5吨的单价 v_price2 number(10,2);--超过5吨不足10吨单价 v_price3 number(10,2);--超过10吨单价 v_account t_account%rowtype;--记录型 v_usenum2 number(10,2);--使用吨数 v_money number(10,2);--水费金额begin --对单价进行赋值 v_price1:=2.45; v_price2:=3.45; v_price3:=4.45; --变量赋值 select * into v_account from t_account where year='2012' and month='01' and owneruuid=1; --使用吨数 v_usenum2:=round(v_account.usenum/1000,2); --计算金额(阶梯水费) if v_usenum2&lt;=5 then --第一个阶梯 v_money:=v_price1*v_usenum2; elsif v_usenum2&gt;5 and v_usenum2&lt;=10 then --第二个阶梯 v_money:=v_price1*5 + v_price2*(v_usenum2-5); else --第三个阶梯 v_money:=v_price1*5+v_price2*5+v_price3*(v_usenum2-10); end if; --输出 DBMS_OUTPUT.put_line('吨数:'||v_usenum2||'金额:'||v_money|| '上月字数:'||v_account.num0||'本月字数'||v_account.num1); exception when NO_DATA_FOUND then DBMS_OUTPUT.put_line('没有找到数据'); when TOO_MANY_ROWS then DBMS_OUTPUT.put_line('返回的数据有多行');end; C、循环1234567891011121314151617181920212223242526272829303132333435363738394041--无条件循环loop 循环语句end loop;--案例:输出从1开始的100个数declare v_num number:=1;begin loop dbms_output.put_line(v_num); v_num:=v_num+1; exit when v_num&gt;100; end loop;end;--条件循环while 条件loopend loop;--案例:输出从1开始的100个数declare v_num number:=1;begin while v_num&lt;=100 loop dbms_output.put_line(v_num); v_num:=v_num+1; end loop;end; --for循环for 变量 in 起始值..终止值loopend loop;--案例: 输出从1开始的100个数begin for v_num in 1..100 loop dbms_output.put_line(v_num); end loop;end; D.游标 游标是系统为用户开设的一个数据缓冲区,存放 SQL 语句的执行结果。 我们可以把游标理解为 PL/SQL 中的结果集. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152--语法cursor 游标名称 is SQL 语句;open 游标名称loopfetch 游标名称 into 变量exit when 游标名称%notfoundend loop;close 游标名称--打印业主类型为 1 的价格表declare v_pricetable t_pricetable%rowtype;--价格行对象 cursor cur_pricetable is select * from t_pricetable where ownertypeid=1;--定义游标begin open cur_pricetable;--打开游标 loop fetch cur_pricetable into v_pricetable;--提取游标到变量 exit when cur_pricetable%notfound;--当游标到最后一行下面退出循环 dbms_output.put_line('价格:'||v_pricetable.price ||'吨位：'||v_pricetable.minnum||'-'||v_pricetable.maxnum); end loop; close cur_pricetable;--关闭游标end; --带参数的游标declarev_pricetable T_PRICETABLE%rowtype;--价格行对象cursor cur_pricetable(v_ownertypeid number) is select *from T_PRICETABLE where ownertypeid=v_ownertypeid;--定义游标beginopen cur_pricetable(2);--打开游标loopfetch cur_pricetable into v_pricetable;--提取游标到变量exit when cur_pricetable%notfound;--当游标到最后一行下面退出循环dbms_output.put_line('价格:'||v_pricetable.price ||'吨位：'||v_pricetable.minnum||'-'||v_pricetable.maxnum );end loop;close cur_pricetable;--关闭游标end ;--for循环提取游标值(推荐使用)declarecursor cur_pricetable(v_ownertypeid number) is select *from T_PRICETABLE where ownertypeid=v_ownertypeid;--定义游标beginfor v_pricetable in cur_pricetable(3)loopdbms_output.put_line('价格:'||v_pricetable.price ||'吨位：'||v_pricetable.minnum||'-'||v_pricetable.maxnum );end loop;end ;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle(三)]]></title>
    <url>%2F2018%2F12%2F18%2FOracle-(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[哪里有你，我去哪里。 代鑫-&lt;妄越&gt; 一、视图 视图是一种数据库对象,是从一个或多个数据表或视图中导出的虚表,是对数据表进行查询的结果. 优点: 1.简化数据操作. ​ 2.着重于特定的数据. ​ 3.提供简单有效的安全机制,可以定制不同用户对数据的访问权限. ​ 4.提供向后兼容性. 1234567891011121314--创建视图的语法:CREATE [OR REPLACE] [FORCE] VIEW view_nameAS subquery[WITH CHECK OPTION ][WITH READ ONLY]--格式解释:--OR REPLACE ：若所创建的试图已经存在，ORACLE 自动重建该视图；--FORCE ：不管基表是否存在 ORACLE 都会自动创建该视图；--subquery ：一条完整的 SELECT 语句，可以在该语句中定义别名；--WITH CHECK OPTION ：插入或修改的数据行必须满足视图定义的约束；--WITH READ ONLY ：只读,该视图上不能进行任何 DML 操作。--删除视图的语法:Drop view view_name; 简单视图:(单表查询)123456789101112131415161718192021--创建视图 ：业主类型为 1 的业主信息create or replace view view_owners1 as select * from t_owners where ownertype=1;--查询视图select * from view_owners1 where addressid=1;--修改视图update view_owners1 set name='王刚' where id=2;--带检查约束的视图: 根据地址表（T_ADDRESS）创建视图 VIEW_ADDRESS2 ,内容为区域 ID为 2 的记录。create or replace view view_address2 asselect * from T_ADDRESS where areaid=2with check option --带id约束,需根据约束修改,不能修改id.-- 只读视图的创建与使用:(不能修改)create or replace view view_owners1 asselect * from T_OWNERS where ownertypeid=1with read only--创建带错误的视图:(不存在的表创建视图)create or replace FORCE view view_TEMP asselect * from T_TEMP 复杂视图:(有聚合函数或多表关联查询)1234567891011121314151617181920--多表关联查询: 创建视图，查询显示业主编号，业主名称，业主类型名称create or replace view view_owners asselect o.id 业主编号,o.name 业主名称,ot.name 业主类型from T_OWNERS o,T_OWNERTYPE otwhere o.ownertypeid=ot.id--查询视图select * from view_owners;--修改视图update view_owners set 业主名称='范小冰' where 业主编号=1;--修改成功update view_owners set 业主类型='普通居民' where 业主编号=1;--修改失败--原因:所需改的列不属于键保留表的列。--分组聚合统计查询: 创建视图，按年月统计水费金额create view view_accountsum asselect year,month,sum(money) moneysumfrom T_ACCOUNTgroup by year,monthorder by year,month--用到聚合函数，没有键保留表，所以只能查询,无法执行 update. 二.物化视图 物化视图与普通视图的区别是物化视图是建立的副本，它类似于一张表，需要占用存储空间。而对一个物化视图查询的执行效率与查询一个表是一样的. 优缺点： – 用空间换时间，查询效率快 ​ – 占有一定的空间，数据不能及时更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475--创建物化视图语法CREATE METERIALIZED VIEW view_name[BUILD IMMEDIATE | BUILD DEFERRED ]REFRESH [FAST|COMPLETE|FORCE][ON [COMMIT |DEMAND ] | START WITH (start_time) NEXT(next_time)]ASsubquery--BUILD IMMEDIATE 是在创建物化视图的时候就生成数据,默认为 BUILD IMMEDIATE。--BUILD DEFERRED 则在创建时不生成数据，以后根据需要再生成数据。--刷新（REFRESH）：指当基表发生了 DML 操作后，物化视图何时采用哪种方式和基表进行同步。--REFRESH 后跟着指定的刷新方法有三种：FAST、 COMPLETE、 FORCE。 --FAST刷新采用增量刷新，只刷新自上次刷新以后进行的修改。如果创建REFRESH FAST增量刷新的物化视图，必须首先创建物化视图日志.--COMPLETE 刷新对整个物化视图进行完全的刷新。--如果选择 FORCE 方式，则 Oracle 在刷新时会去判断是否可以进行快速刷新，如果可以则采用 FAST 方式，否则采用 COMPLETE的方式。 FORCE 是默认的方式。--刷新的模式有两种：ON DEMAND 和 ON COMMIT。 ON DEMAND 指需要手动刷新物化视图（默认）。 ON COMMIT 指在基表发生 COMMIT 操作时自动刷新。--案例:--创建手动刷新的物化视图,查询地址 ID,地址名称和所属区域名称.create materialized view mv_addressasselect ad.id,ad.name adname,ar.name ar_namefrom t_address ad,t_area arwhere ad.areaid=ar.id--删除物化视图drop materialized view mv_address--执行上边的语句后查询select * from mv_address;--向地址表（T_ADDRESS）中插入一条新记录insert into t_address values(8,'宏福苑小区',1,1);--再次执行上边的语句进行查询，会发现新插入的语句并没有出现在物化视图中。--需要通过下面的语句（PL/SQL），手动刷新物化视图：beginDBMS_MVIEW.refresh('MV_ADDRESS','C');--C代表完全刷新end;--或者通过下面的命令手动刷新物化视图：EXEC DBMS_MVIEW.refresh('MV_ADDRESS','C');--注意：此语句需要在命令窗口中执行。--再次查询物化视图，就可以查询到最新的数据.--创建自动刷新的物化视图create materialized view mv_address2refreshon commitasselect ad.id,ad.name adname,ar.name ar_namefrom t_address ad,t_area arwhere ad.areaid=ar.id--创建时不生成数据的物化视图--第一次生成数据必须手动执行刷新create materialized view mv_address3build deferredrefreshon commitasselect ad.id,ad.name adname,ar.name ar_namefrom t_address ad,t_area arwhere ad.areaid=ar.id;--创建增量刷新的物化视图(了解,笔记不全)--创建增量刷新的物化视图，必须首先创建物化视图日志:--记录基表发生了拿些变化,用记录去更新物化视图create materialized view log on t_address with rowid；create materialized view log on t_area with rowid;--创建的物化视图日志名称为 MLOG$_表名称--创建物化视图,必须有基表的rowidcreate materialized view mv_address4refresh fastasselect ad.rowid adrowid,ar.rowid arrowid, ad.id,ad.nameadname,ar.name ar_namefrom t_address ad,t_area arwhere ad.areaid=ar.id; 三.序列 序列是ORACLE提供的用于产生一系列唯一数字的数据库对象。 12345678910111213141516171819202122232425262728293031323334--创建序列的语法create sequence 序列名称;--通过序列的伪列来访问序列的值--NEXTVAL 返回序列的下一个值select 序列名称.nextval from dual--CURRVAL 返回序列的当前值select 序列名称.currval from dual--案例create sequence myemp3_seq;--使用序列：insert into myemp3 values(myemp3_seq.nextval,'张三','男',10,'101001@qq.com');--获取当前值使用myemp3_seq.currval-- 注意：myemp3_seq.nextval 每调用一次nextval指针向后移动一位，也就是该序列增加一次；--创建复杂序列CREATE SEQUENCE sequence //创建序列名称[INCREMENT BY n] //递增的序列值是 n 如果 n 是正数就递增,如果是负数就递减 默认是1[START WITH n] //开始的值,递增默认是 minvalue 递减是 maxvalue[&#123;MAXVALUE n | NOMAXVALUE&#125;] //最大值[&#123;MINVALUE n | NOMINVALUE&#125;] //最小值[&#123;CYCLE | NOCYCLE&#125;] //循环/不循环[&#123;CACHE n | NOCACHE&#125;];//分配并存入到内存中(默认缓存20)--案例--有最大值的非循环序列create sequence seq_test1maxvalue 20; --超过20报错--修改和删除序列--修改序列：使用 ALTER SEQUENCE 语句修改序列，不能更改序列的 START WITH 参数ALTER SEQUENCE 序列名称 MAXVALUE 5000 CYCLE;--删除序列DROP SEQUENCE 序列名称; 四.同义词:实质是别名 提供一定程度的安全性。同时，同义词的易用性较好，降低了数据库用户的 SQL 语句复杂度。 123456789101112--创建同义词create [public] SYNONYM synooym for object;--其中 synonym 表示要创建的同义词的名称，object 表示表，视图，序列等我们要创建同义词的对象的名称。--私有同义词create synonym OWNERS for T_OWNERS;--公有同义词:(以其他用户登录,也可使用)create public synonym OWNERS2 for T_OWNERS;--查询同义词select * from 同义词名称varchar是varchar2的同义词(兼容性的作用) 五.索引 索引是用于加速数据存取的数据对象。合理的使用索引可以大大降低 i/o 次数,从而提高数据访问性能。 索引是需要占据存储空间的，也可以理解为是一种特殊的数据。形式类似于一棵“树”，而树的节点存储的就是每条记录的物理地址，也就是我们提到的伪列(ROWID). 索引建立在表的一列或多个列上的辅助对象，目的是加快访问表中的数据. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051--普通索引:create index 索引名称 on 表名(列名);--如我们经常要根据业主名称搜索业主信息，所以我们基于业主表的 name 字段来建立索引.create index index_owners_name on T_OWNERS(name)--索引性能测试--创建一个两个字段的表create table T_INDEXTEST (ID NUMBER,NAME VARCHAR2(30));--编写 PL/SQL 插入 100 万条记录BEGINFOR i in 1..1000000loopINSERT INTO T_INDEXTEST VALUES(i,'AA'||i);end loop;commit;END;--创建完数据后，根据 name 列创建索引CREATE INDEX INDEX_TESTINDEX on T_INDEXTEST(name)--执行下面两句 SQL 执行SELECT * from T_INDEXTEST where ID=765432; --用时0.031SELECT * from T_INDEXTEST where NAME='AA765432'; --用时0.016--唯一索引:--需要在某个表某个列创建索引，而这列的值是不会重复的。这是可以创建唯一索引.create unique index 索引名称 on 表名(列名);--在业主表的水表编号一列创建唯一索引create unique index index_owners_watermeter on T_OWNERS(watermeter);--复合(组合)索引:--要对某几列进行查询，比如，我们经常要根据学历和性别对学员进行搜索,可以建立复合索引，也就是基于两个以上的列建立一个索引.create index 索引名称 on 表名(列名,列名.....);--根据地址和门牌号对学员表创建索引create index owners_index_ah on T_OWNERS(addressid,housenumber);--面试题：经常查询的两个字段,对其建立索引,是建立复合索引快还是对每个字段单独建索引快？ 复合索引,一个索引对应一棵树,单独建索引就是两棵树,查询速度低于一个索引.--反向键索引:--当某个字段的值为连续增长的值，如果构建标准索引，会形成歪脖子树。--这样会增加查询的层数，性能会下降。建立反向键索引，可以使索引的值变得不规则，从而使索引树能够均匀分布。create index 索引名称 on 表名(列名) reverse;--位图索引:--位图索引适合创建在低基数列(有限的值,比如性别：男和女)上--位图索引不直接存储 ROWID，而是存储字节位到ROWID的映射--优点：减少响应时间，节省空间占用create bitmap index 索引名称 on 表名(列名);--在 T_owners 表的 ownertypeid 列上建立位图索引create bitmap index index_owners_typeid on T_OWNERS(ownertypeid); 1234--scott用户解锁与赋权:scott/tiger alter user scott identified by "tiger" account unlock; grant dba to scott]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白日梦想家]]></title>
    <url>%2F2018%2F12%2F14%2F%E7%99%BD%E6%97%A5%E6%A2%A6%E6%83%B3%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[青春永驻，骑马少年。 &lt;白日梦想家&gt;台词 二刷的电影，依旧那么让人有想不顾一切出走的冲动，渴望自由和远方的美景。影片中的音乐也是经典。 主人公华特*米蒂是一名在《生活》杂志工作了16年的胶片洗印经理，他性格内向，甚至无法跟心仪的同事谢莉尔开口搭讪，面对生活他像个旁观者，时常“放空”做白日英雄梦。直到有一天公司被并购，杂志需要做最后一期的封面，而封面成功与否的关键是找到狂野摄影师肖恩的寄给他的25号胶片，华特终于开口搭讪谢莉尔，并在她和母亲的鼓励下踏上真正的冒险之旅，一路历经格林兰岛、冰岛、阿富汗，看到冰原、大海、喜马拉雅山……沃特的白日梦远不及现实壮丽。 以下为影片中的截图： 你都没看过世界，哪来的世界观。世间不值得，但世间很美，值得你去看看。 一路冒险，一直追寻，影片也娓娓讲述了主人公的成长，最后结尾的胶卷也是惊喜。 认识世界，克服困难；洞悉所有，贴近生活；寻找真爱，感受彼此； ​ 这就是生活的意义。 25号胶卷]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>movie</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习-常用命令]]></title>
    <url>%2F2018%2F12%2F12%2FLinux%E5%AD%A6%E4%B9%A0-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[唯愿会及时拥抱入眠，留住这世上最暖一面，茫茫人海取暖渡过 最冷一天。 张国荣-&lt;最冷一天&gt; 一、Linux的目录结构 Linux系统是文件系统.根目录是”/“,以树型结构来管理. ~ 代表root目录.root为超级管理员. 二、Linux常用命令1、切换目录命令 cd12345cd app 切换到app目录cd .. 切换到上一层目录cd / 切换到系统根目录cd ~ 切换到用户主目录cd - 切换到上一个所在目录 2、列出文件列表 ls ll (dir)ls(list)用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。 1234ls --help 查看帮助信息ls -a 显示所有文件或目录（包含隐藏的文件）ls -l 缩写成ll,显示详情信息//在linux中以 . 开头的文件都是隐藏的文件 3、创建与删除目录1234567//创建mkdir(make directory)命令可用来创建子目录。mkdir app 在当前目录下创建app目录mkdir –p app2/test 级联创建aap2以及test目录//删除rmdir(remove directory)命令可用来删除“空”的子目录;rmdir app 删除app目录 4、浏览文件1234567891011121314cat //用于显示文件的内容//格式： cat[参数]&lt;文件名&gt; cat install.logmore //一般用于要显示的内容会超过一个画面长度的情况。 按空格键显示下一个画面，回车显示下一行内容。 按q键退出查看 more install.logless //和more用法类似，不同的是可以PgUP和PgDn键来进行上下翻页 less install.logtail //用于展示文件的后几行内容 tail -10 install.log 查看后10行数据 tail -f catalina.log 动态查看日志 ctrl+c 结束查看 5、文件操作123456789101112131415161718192021222324252627//cp是copy操作//mv它是move相当于剪切cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。cp a.txt b.txt 将a.txt复制为b.txt文件cp a.txt ../ 将a.txt文件复制到上一层目录中cp install.log /a/myinstall.log 将install.log复制到a目录下并重命名为myinstall.log //mv 移动或者重命名mv a.txt ../ 将a.txt文件移动到上一层目录中mv a.txt b.txt 将a.txt文件重命名为b.txtmv install.log /b/my.log 将install.log移动到b目录下并重命名为my.log //rm它可以帮助我们删除文件与目录//rm 删除文件并询问用法：rm [选项]... 文件...rm a.txt 删除a.txt文件删除需要用户确认，y/n//rm -f 直接删除不询问rm -f a.txt 不询问，直接删除//rm 删除目录rm -r a 递归删除//不询问递归删除（慎用!!!）rm -rf a 不询问递归删除rm -rf * 删除所有文件rm -rf /* 自杀 6、打包压缩与解压tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。 12345678910111213141516171819//常用参数： tar --help-c：创建一个新tar文件-v：显示运行过程的信息-f：指定文件名-z：调用gzip压缩命令进行压缩-t：查看压缩文件的内容-x：解开tar文件 //打包：tar -cvf ab.tar a.log b.log 将a,b两个文件打包成ab.tartar –cvf xxx.tar ./*//打包并且压缩：tar -zcvf ab.tar.gz a.log b.log 将a,b两个文件打包并压缩成ab.tartar –zcvf xxx.tar.gz ./* //解压tar –xvf xxx.tartar -xvf xxx.tar.gz -C /usr/aaatar -xvf ab.tar.gz -C /b 将ab.tar.gz解压到b目录下 7、文件查找查找符合条件的文件find 查找文件中符合条件的字符串grep 1234567891011121314//find指令用于查找符合条件的文件示例：find / -name “ins*” 查找文件名称是以ins开头的文件find / -name “ins*” –ls 显示文件的详情信息find / –user itcast –ls 查找用户itcast的文件find / –user itcast –type d –ls 查找用户itcast的目录find /-perm -777 –type d-ls 查找权限是777的文件//grep查找文件里符合条件的字符串用法: grep [选项]... PATTERN [FILE]...示例：grep lang anaconda-ks.cfg 在anaconda-ks.cfg文件中查找langgrep lang anaconda-ks.cfg –color 高亮显示(加粗)grep lang anaconda-ks.cfg –color -A5 -B5 在anaconda-ks.cfg文件中查找lang并加粗,显示前后5行. 8.其他常用命令123456789101112131415pwd 显示当前所在目录 touch创建一个空文件 touch a.txt ll -h 友好显示文件大小 wget 下载资料(有网络) wget http://nginx.org/download/nginx-1.9.12.tar.gz //命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。 mkdir test &amp;&amp; cd test 创建test文件夹并进入test目录 三、VIM编辑器1234567891011121314151617181920212223在Linux下一般使用vi编辑器来编辑文件。 vi既可以查看文件也可以编辑文件。 三种模式：命令行、插入、底行模式。切换到命令行模式：按Esc键；切换到插入模式：按 i 、o、a键； i 在当前位置前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行切换到底行模式：按:(冒号) 打开文件：vim file退出：esc -&gt; :q修改文件：输入i进入插入模式保存并退出：esc-&gt;:wq不保存退出：esc-&gt;:q! 快捷键：dd – 快速删除一行yy - 复制当前行nyy - 从当前行向后复制几行p - 粘贴R – 替换 四、重定向12345678910111213&gt; 重定向输出，覆盖原有内容；&gt;&gt; 重定向输出，又追加功能；示例：cat /etc/passwd &gt; a.txt 将输出定向到a.txt中cat /etc/passwd &gt;&gt; a.txt 输出并且追加//例如：echo "helloworld" 将helloworld打印到控制台echo "helloworld" &gt; a.txt 将helloworld输出到a.txt文件中cat a.txt &gt; b.txt 将查看的a.txt的内容输出到b.txt中echo "good java" &gt;&gt; b.txt 将good java输出并追加到b.txt文件中 //Linux查看ip地址信息ifconfig &gt; ifconfig.txt 将查看的ip地址信息输出到ifconfig.txt文件中 五、管道管道是Linux命令中重要的一个概念,其作用是将一个命令的输出用作另一个命令的输入. 笔试题：ps –ef | grep java 查询名称中包含java的进程 1234567//示例:ls --help | more 分页查询帮助信息ps –ef | grep java 查询名称中包含java的进程 ifconfig | morecat index.html | moreps –ef | grep aio 六、系统常用命令12345678910111213141516171819date 显示或设置系统时间date 显示当前系统时间date -s “2014-01-01 10:10:10“ 设置系统时间 df 显示磁盘信息df –h 友好显示大小 free 显示内存状态free –m 以mb单位显示内存组昂头 top 显示，管理执行中的程序 clear 清屏幕ps 正在运行的某个进程的状态ps –ef 查看所有进程ps –ef | grep ssh 查找某一进程 kill 杀掉某一进程kill 2868 杀掉2868编号的进程kill -9 2868 强制杀死进程 du 显示目录或文件的大小。du –h 显示当前目录的大小who 显示目前登入系统的用户信息。uname 显示系统信息。uname -a 显示本机详细信息。依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称 七、Linux下用户和组的管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//用户管理：useradd 添加一个用户useradd test 添加test用户useradd test -d /home/t1 为指定用户home目录passwd 设置、修改密码passwd test 为test用户设置密码 切换登录：ssh -l test -p 22 192.168.19.128 端口22 userdel 删除一个用户userdel test 删除test用户(不会删除home目录)userdel –r test 删除用户以及home目录 //组管理当在创建一个新用户user时,若没有指定他所属于的组,就建立一个和该用户同名的私有组.//创建用户时也可以指定所在组groupadd 创建组groupadd public 创建一个名为public的组useradd u1 –g public 创建用户指定组 groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。groupdel public //id命令：查看一个用户的UID和GID直接使用 id直接使用 id 用户名//su命令：切换用户su test 切换到test用户su - test 切换到test用户，并且将环境也切换到test用户的环境（推荐使用） 【账户文件】/etc/passwd 用户文件/etc/shadow 密码文件/etc/group 组信息文件【用户文件】root:x:0:0:root:/root:/bin/bash账号名称： 在系统中是唯一的用户密码： 此字段存放加密口令用户标识码(User ID)： 系统内部用它来标示用户组标识码(Group ID)： 系统内部用它来标识用户属性用户相关信息： 例如用户全名等用户目录： 用户登录系统后所进入的目录用户环境: 用户工作的环境【密码文件】shadow文件中每条记录用冒号间隔的9个字段组成.用户名：用户登录到系统时使用的名字，而且是惟一的口令： 存放加密的口令最后一次修改时间: 标识从某一时刻起到用户最后一次修改时间最大时间间隔: 口令保持有效的最大天数，即多少天后必须修改口令最小时间间隔： 再次修改口令之间的最小天数警告时间：从系统开始警告到口令正式失效的天数不活动时间：口令过期少天后，该账号被禁用失效时间：指示口令失效的绝对天数(从1970年1月1日开始计算)标志：未使用【组文件】root:x:0:组名：用户所属组组口令：一般不用GID：组ID用户列表：属于该组的所有用户 八、Linux文件权限管理 12345678910111213//Linux三种文件类型：普通文件：包括文本文件、数据文件、可执行的二进制程序文件等。目录文件：Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。设备文件：Linux系统把每一个设备都看成是一个文件。//文件类型标识://普通文件（-）//目录（d）//符号链接（l）* 进入etc可以查看，相当于快捷方式字符设备文件（c）块设备文件（s）套接字（s）命名管道（p） 1、权限设置：1234567chmod 变更文件或目录的权限。chmod 755 a.txtchmod u=rwx,g=rx,o=rx a.txtchmod 000 a.txt / chmod 777 a.txt chown变更文件或目录改文件所属用户和组chown u1:public a.txt ：变更当前的目录或文件的所属用户和组chown -R u1:public dir ：变更目录中的所有的子目录及文件的所属用户和组 九、常用网络操作1234567891011121314151617181920212223242526272829//主机名配置hostname 查看主机名hostname xxx 修改主机名 重启后无效如果想要永久生效，可以修改/etc/sysconfig/network文件//IP地址配置Setup 设置ip地址ifconfig 查看(修改)ip地址(重启后无效)ifconfig eth0 192.168.12.22 修改ip地址如果想要永久生效修改 /etc/sysconfig/network-scripts/ifcfg-eth0文件//域名映射/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用//网络服务管理service network status 查看指定服务的状态service network stop 停止指定服务service network start 启动指定服务service network restart 重启指定服务service ---status–all 查看系统中所有后台服务netstat –nltp 查看系统中网络进程的端口监听情况//防火墙设置防火墙根据配置文件/etc/sysconfig/iptables来控制本机的”出”、”入”网络访问行为。service iptables status 查看防火墙状态service iptables stop 关闭防火墙service iptables start 启动防火墙chkconfig iptables off 禁止防火墙自启]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle(二)]]></title>
    <url>%2F2018%2F12%2F05%2FOracle(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[我有整个宇宙想讲给你听，张嘴却吐不出半粒星辰。 方拾贰-&lt;山下&gt; 以下结合基础篇建表语句所建的表查询。 一.单表查询1.简单条件查询1234567891011121314151617181920212223241.精确查询:--查询水表编号为 30408 的业主记录select * from T_OWNERS where WATERMETER='30408';2.模糊查询:--查询业主名称包含“刘”的业主记录select * from t_owners where name like '%刘%';3. and 运算符:--查询业主名称包含“刘”的并且门牌号包含 5 的业主记录select * from t_owners where name like '%刘%' and housenumber like '%5%';4. or 运算符:--查询业主名称包含“刘”的或者门牌号包含 5 的业主记录select * from t_owners where name like '%刘%' or housenumber like '%5%';5.and 与 or 运算符混合使用:--查询业主名称包含“刘”的或者门牌号包含 5 的业主记录，并且地址编号为 3 的记录。select * from t_owners where (name like '%刘%' or housenumber like '%5%') and addressid=3;6. 范围查询:--查询台账记录中用水字数大于等于 10000，并且小于等于 20000 的记录select * from t_account where usenum &gt;= 10000 and usenum &lt;= 20000;select * from t_account where usenum between 10000 and 20000;7. 空值查询:--查询 T_PRICETABLE 表中 MAXNUM 为空的记录select * from t_pricetable where maxnum is null;--查询 T_PRICETABLE 表中 MAXNUM 不为空的记录select * from t_pricetable where maxnum is not null; 2.去掉重复记录及排序123456--查询业主表中的地址 ID,不重复显示select distinct addressid from t_owners;--对 T_ACCOUNT 表按使用量进行升序排序select * from t_account order by usenum;--对 T_ACCOUNT 表按使用量进行降序排序select * from t_account order by usenum desc; 3.基于伪列的查询1234--ROWID返回的就是该行的物理地址,可以快速的定位表中的某一行.select rowID,t.* from t_area t;--ROWNUM可以限制查询结果集中返回的行数,用于分页.select rownum,t.* from t_ownertype t; 4.聚合函数123456789101112131415161718192021--1.求和 sum:--统计 2012 年所有用户的用水量总和select sum(usenum) from t_account where year='2012';--2.求平均 avg:--统计 2012 年所有用水量（字数）的平均值select avg(usenum) from t_account where year='2012';--3.求最大值 max:--统计 2012 年最高用水量（字数）select max(usenum) from t_account where year='2012';--4.求最小值 min:--统计 2012 年最低用水量（字数）select min(usenum) from t_account where year='2012';--5.统计记录个数 count:--统计业主类型 ID 为 1 的业主数量select count(*) from t_owners where ownertypeid=1;--6.分组聚合 Group by--按区域分组统计水费合计数select areaid,sum(money) from t_account group by areaid;--7.分组后条件查询 having--查询水费合计大于 169000 的区域及水费合计select areaid,sum(money) from t_account group by areaid having sum(money)&gt;169000; 二.多表查询 内连接: inner join (inner可以省略)​ 显示内连接:在sql中显示的调用 inner join关键字.​ select from 表1 inner join 表2 on 关联条件;​ 例: SELECT FROM classes c INNER JOIN student s ON c.cid=s.cid;​ 隐式内连接: 在sql中没有调用 inner join关键字.​ select * from 表1,表2 where 关联条件;(以下均采用此种) 外连接: outer join (outer可以省略)​ 左外连接:​ select from 表1 left outer join 表2 on 关联条件;​ 右外连接:​ select from 表1 right outer join 表2 on 关联条件; 1.多表内连接查询12345678910111213--查询显示业主编号，业主名称，业主类型名称(两表连接)select ow.id 业主编号,ow.name 业主名称,ot.name 业主类型名称from t_owners ow,t_ownertype ot where ow.ownertypeid=ot.id; --查询显示业主编号，业主名称、地址和业主类型(三表连接)select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ot.name 业主类型名称 from t_owners ow,t_ownertype ot,t_address adwhere ow.ownertypeid=ot.id and ow.addressid=ad.id;--查询显示业主编号、业主名称、地址、所属区域、业主分类(四表连接)select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ae.name 所属区域,ot.name 业主类型名称from t_owners ow,t_ownertype ot,t_address ad,t_area aewhere ow.ownertypeid=ot.id and ow.addressid=ad.id and ad.areaid=ae.id; --查询显示业主编号、业主名称、地址、所属区域、收费员、业主分类(五表连接)select ow.id 业主编号,ow.name 业主名称,ad.name 地址,ae.name 所属区域,op.name 收费员,ot.name 业主类型名称 from t_owners ow,t_ownertype ot,t_address ad,t_area ae,t_operator opwhere ow.ownertypeid=ot.id and ow.addressid=ad.id and ad.areaid=ae.id and ad.operatorid=op.id; 2.左外连接查询1234567--查询业主的账务记录，显示业主编号、名称、年、月、金额。如果此业主没有账务记录也要列出姓名。--sql标准:select ow.id,ow.name,ac.year ,ac.month,ac.moneyfrom t_owners ow left join t_account ac on ow.id=ac.owneruuid;--oracle标准:select ow.id,ow.name,ac.year ,ac.month,ac.moneyfrom t_owners ow ,t_account ac where ow.id=ac.owneruuid(+); 3.右外连接查询1234567--查询业主的账务记录，显示业主编号、名称、年、月、金额,如果账务记录没有对应的业主信息，也要列出记录.--sql标准:select ow.id,ow.name,ac.year ,ac.month,ac.moneyfrom t_owners ow right join t_account ac on ow.id=ac.owneruuid;--oracle标准:select ow.id,ow.name,ac.year ,ac.month,ac.moneyfrom t_owners ow ,t_account ac where ow.id(+)=ac.owneruuid; 4.子查询–where 子句中的子查询12345678910111213单行子查询:只返回一条记录,使用单行操作符(&gt;,&lt;,=...)--查询 2012 年 1 月用水量大于平均值的台账记录select * from t_account where year='2012' and month='01'and usenum&gt;(select avg(usenum) from t_account where year='2012' and month='01');多行子查询:返回了多条记录,使用多行操作符(in,any,all)--in 等于列表中的任何一个--any 和子查询返回的任意一个值做比较--all 和子查询返回的所有值做比较--查询地址编号为 1 、3、4 的业主记录select * from t_owners where addressid in(1,3,4);--查询地址含有“花园”的业主的信息select * from t_owners where addressid in(select id from t_address where name like '%花园%'); –from 子句中的子查询12345--(为多行子查询)--查询显示业主编号，业主名称，业主类型名称，条件为业主类型为”居民”select * from(select o.id 业主编号,o.name 业主名称,ot.name 业主类型名称 from t_owners o,t_ownertype ot where o.ownertypeid=ot.id)where 业主类型名称='居民'; –select子句的子查询123456789--(为单行子查询)--列出业主信息，包括 ID，名称，所属地址select id,name,(select name from t_address where id=addressid) addressname from t_owners;--列出业主信息，包括 ID，名称，所属地址，所属区域select id,name,( select name from t_address where id=addressid )addressname,( select (select name from t_area where id=areaid ) fromt_address where id=addressid )adrenamefrom t_owners; 三.分页查询12345678910111213141516171819202122简单分页--分页查询台账表 T_ACCOUNT，每页 10 条记录select rownum,t.* from t_account t where rownum&lt;=10;--显示第 11 条到第 20 条的记录select * from(select rownum r,t.* from t_account t where rownum&lt;=20)where r&gt;10;=====================================select * from(select rownum r, t.* from t_account t)where r&gt;10 and r&lt;=20;--分页查询台账表 T_ACCOUNT，每页 10 条记录，按使用字数降序排序select * from (select rownum r,t.* from (select * from t_account order by usenum desc) t where rownum&lt;=20) where r&gt;10; =====================================select * from(select rownum r, t.* from (select * from t_account order by usenum desc) t) where r&gt;10 and r&lt;=20; 四.单行函数12345678910111213141516171819202122232425262728293031323334353637383940414243--求字符串长度 LENGTHselect length('ABCD') from dual;--求字符串的子串 SUBSTR （源字符串,从第几位截取,截取字符串）select substr('ABCD',2,2) from dual;--字符串拼接 CONCATselect concat('ABC','D') from dual;--字符串拼接2select 'ABC'||'D' from dual;--数值函数--四舍五入函数 ROUNDselect round(100.567) from dual; --101select round(100.567,2) from dual;--保留两位小数 100.57--截取函数 TRUNCselect trunc(100.567) from dual; --100select trunc(100.567,2) from dual; --保留两位小数 100.56--取模 MODselect mod(10,3) from dual;--日期函数--获取当前日期和时间select sysdate from dual;--加月函数 ADD_MONTHS ：在当前日期基础上加指定的月,减月-2;select add_months(sysdate,2) from dual;--求所在月最后一天 LAST_DAYselect last_day(sysdate) from dual;--日期截取 TRUNCselect TRUNC(sysdate) from dual; --把时间截掉--截取年select TRUNC(sysdate,'yyyy') from dual;--截取月select TRUNC(sysdate,'mm') from dual;--转换函数--数字转字符串 TO_CHARselect TO_CHAR(1024) from dual;--日期转字符串 TO_CHARselect TO_CHAR(sysdate,'yyyy-mm-dd') from dual;select TO_CHAR(sysdate,'yyyy-mm-dd hh:mi:ss') from dual;--字符串转日期 TO_DATEselect TO_DATE('2017-01-01','yyyy-mm-dd') from dual;--字符串转数字 TO_NUMBERselect to_number('100') from dual; –其他函数12345678910111213141516171819202122232425262728293031--其他函数--空值处理函数 NVLselect NVL(NULL,0) from dual;--显示价格表中业主类型 ID 为 1 的价格记录，如果上限值为 NULL,则显示 9999999select PRICE,MINNUM,NVL(MAXNUM,9999999)from T_PRICETABLE where OWNERTYPEID=1;--空值处理函数 NVL2(null,0,100) 如果为null,显示100,不为null,显示0--显示价格表中业主类型 ID 为 1 的价格记录，如果上限值为 NULL,显示“不限”select PRICE,MINNUM,NVL2(MAXNUM,to_char(MAXNUM) , '不限 ')from T_PRICETABLE where OWNERTYPEID=1;--条件取值 decode--语法decode(条件,值 1,翻译值 1,值 2,翻译值 2,...值 n,翻译值 n,缺省值)【功能】 根据条件返回相应值.--显示下列信息（不要关联查询业主类型表，直接判断 1 2 3 的值）select name,decode( ownertypeid,1,' 居 民 ',2,' 行 政 事 业 单 位',3,'商业') as 类型 from T_OWNERS;--或者select name ,(case ownertypeid when 1 then '居民' when 2 then '行政事业单位' when 3 then '商业' else '其它'end) from T_OWNERS;--或者select name,(case when ownertypeid= 1 then '居民' when ownertypeid= 2 then '行政事业' when ownertypeid= 3 then '商业'end ); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152select last_day(sysdate) from dual;--日期截取 TRUNCselect TRUNC(sysdate) from dual; --把时间截掉--截取年select TRUNC(sysdate,&apos;yyyy&apos;) from dual;--截取月select TRUNC(sysdate,&apos;mm&apos;) from dual;--转换函数--数字转字符串 TO_CHARselect TO_CHAR(1024) from dual;--日期转字符串 TO_CHARselect TO_CHAR(sysdate,&apos;yyyy-mm-dd&apos;) from dual;select TO_CHAR(sysdate,&apos;yyyy-mm-dd hh:mi:ss&apos;) from dual;--字符串转日期 TO_DATEselect TO_DATE(&apos;2017-01-01&apos;,&apos;yyyy-mm-dd&apos;) from dual;--字符串转数字 TO_NUMBERselect to_number(&apos;100&apos;) from dual;--其他函数--空值处理函数 NVLselect NVL(NULL,0) from dual;--显示价格表中业主类型 ID 为 1 的价格记录，如果上限值为 NULL,则显示 9999999select PRICE,MINNUM,NVL(MAXNUM,9999999)from T_PRICETABLE where OWNERTYPEID=1;--空值处理函数 NVL2(null,0,100) 如果为null,显示100,不为null,显示0--显示价格表中业主类型 ID 为 1 的价格记录，如果上限值为 NULL,显示“不限”select PRICE,MINNUM,NVL2(MAXNUM,to_char(MAXNUM) , &apos;不限 &apos;)from T_PRICETABLE where OWNERTYPEID=1;--条件取值 decode--语法decode(条件,值 1,翻译值 1,值 2,翻译值 2,...值 n,翻译值 n,缺省值)【功能】 根据条件返回相应值.--显示下列信息（不要关联查询业主类型表，直接判断 1 2 3 的值）select name,decode( ownertypeid,1,&apos; 居 民 &apos;,2,&apos; 行 政 事 业 单 位&apos;,3,&apos;商业&apos;) as 类型 from T_OWNERS;--或者select name ,(case ownertypeid when 1 then &apos;居民&apos; when 2 then &apos;行政事业单位&apos; when 3 then &apos;商业&apos; else &apos;其它&apos;end) from T_OWNERS;--或者select name,(case when ownertypeid= 1 then &apos;居民&apos; when ownertypeid= 2 then &apos;行政事业&apos; when ownertypeid= 3 then &apos;商业&apos;end ); 五.行列转换 1234567891011121314select (select name from T_AREA where id= areaid ) 区域, sum( case when month='01' then money else 0 end) 一月, sum( case when month='02' then money else 0 end) 二月, sum( case when month='03' then money else 0 end) 三月, sum( case when month='04' then money else 0 end) 四月, sum( case when month='05' then money else 0 end) 五月, sum( case when month='06' then money else 0 end) 六月, sum( case when month='07' then money else 0 end) 七月, sum( case when month='08' then money else 0 end) 八月, sum( case when month='09' then money else 0 end) 九月, sum( case when month='10' then money else 0 end) 十月, sum( case when month='11' then money else 0 end) 十一月, sum( case when month='12' then money else 0 end) 十二月from T_ACCOUNT where year='2012' group by areaid; 12345678910select (select name from T_AREA where id= areaid ) 区域,sum( case when month&gt;='01' and month&lt;='03' then money else0 end) 第一季度,sum( case when month&gt;='04' and month&lt;='06' then money else0 end) 第二季度,sum( case when month&gt;='07' and month&lt;='09' then money else0 end) 第三季度,sum( case when month&gt;='10' and month&lt;='12' then money else0 end) 第四季度from T_ACCOUNT where year='2012' group by areaid; 六.分析函数1234567891011121314151617--1. RANK 相同的值排名相同，排名跳跃--对 T_ACCOUNT 表的 usenum 字段进行排序，相同的值排名相同，排名跳跃select rank() over(order by usenum desc ),usenum from T_ACCOUNT;--2. DENSE_RANK 相同的值排名相同，排名连续--对 T_ACCOUNT 表的 usenum 字段进行排序，相同的值排名相同，排名连续select dense_rank() over(order by usenum desc ),usenum from T_ACCOUNT;--3. ROW_NUMBER 返回连续的排名，无论值是否相等--对 T_ACCOUNT 表的 usenum 字段进行排序，返回连续的排名，无论值是否相等select row_number() over(order by usenum desc ),usenum from T_ACCOUNT;--row_number()分析函数实现的分页select * from(select row_number() over(order by usenum desc )rownumber,usenum from T_ACCOUNT)where rownumber&gt;10 and rownumber&lt;=20; 七.集合运算 集合运算，集合运算就是将两个或者多个结果集组合成为一个结果集。 集合运算包括： ​ UNION ALL(并集)，返回各个查询的所有记录，包括重复记录。 ​ UNION(并集)，返回各个查询的所有记录，不包括重复记录。 ​ INTERSECT(交集)，返回两个查询共有的记录。 ​ MINUS(差集)，返回第一个查询检索出的记录减去第二个查询检索出的记录之 后剩余的记录. 12345678910111213141516171819202122232425262728--并集运算--UNION ALL 不去掉重复记录select * from t_owners where id&lt;=7union allselect * from t_owners where id&gt;=5;--UNION 去掉重复记录select * from t_owners where id&lt;=7unionselect * from t_owners where id&gt;=5;--交集运算--intersect 运算符返回同时属于两个集合的记录select * from t_owners where id&lt;=7intersectselect * from t_owners where id&gt;=5;--差集运算--minus 返回属于第一个集合,但不属于第二个集合的记录select * from t_owners where id&lt;=7minusselect * from t_owners where id&gt;=5;--minus 运算符来实现分页select rownum,t.* from T_ACCOUNT t where rownum&lt;=20minusselect rownum,t.* from T_ACCOUNT t where rownum&lt;=10;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows常用软件推荐及下载]]></title>
    <url>%2F2018%2F12%2F04%2FWindows%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%8F%8A%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[承蒙时光洗礼，往事已云淡风轻。 许嵩-&lt;明智之举&gt; 个人常用软件汇总。 浏览器 Google Chrome 浏览器 [下载] ：开发必备。 火狐浏览器 [下载]：必备。 影音播放器 网易云音乐 [下载]：网易大法好。 PotPlayer播放器 [下载]：视频播放利器。 下载工具 IDM下载神器 [绿色破解版]：资源下载神器。 PanDownload [下载]：百度云盘下载限速解决方案。 办公软件 Office各版本 [下载]：不解释。 Office卸载工具 [下载] 压缩软件 Bandzip [下载]：压缩快，简便，同类还有7zip。 截录屏软件 Snipaste [下载]:截图方便工具，强推。 FSCapture [下载]：同样截图功能强大，支持录屏的神器。 Bandicam [下载]：密码：t9qc，绿色版录屏软件。 文本编辑器 Notepad++ [下载]：程序猿必备。 Sublime Text [下载]：程序猿必备。 搜索工具 Everything [下载]：电脑本地快速搜索。 系统安全 火绒安全 [下载]：国产良心安全软件。 Dism++ [下载]：Windows实用工具。 笔记软件 为知笔记 [下载]：顾名思义。 远程软件 TeamViewer [破解版下载]：远程协助软件。 AnyDesk [下载]：免费的远程软件，体积小。 其他软件 PDF阅读器 [绿色便捷版]: 福昕阅读器。 Markdownpad2编辑器 [破解版]：markdown编辑软件。 Typora [下载]：markdown编辑软件(推荐)。 绿色软件网站：（软件书签汇总）更多软件下载地址： 老殁分享：https://www.laomoit.com/ 精品绿色便捷软件：https://www.portablesoft.org/ 小众软件推荐：https://love.appinn.com/ 轻狂志软件分享：https://www.flighty.cn/ 软矿：https://www.rkdot.com/ 免费资源网络社群：https://free.com.tw/ 反斗软件：http://www.apprcn.com/ MSDN,我告诉你：https://msdn.itellyou.cn/ 爱软客：http://www.bokeboke.net/ 飞速下载网：http://fesux.com/windows 异次元软件：https://www.iplaysoft.com/ Tool321：http://www.tool321.com/cn/index.html 谷歌插件下载：http://www.cnplugins.com/ 就是爱分享：http://www.94afx.com/ 软件缘：https://www.appcgn.com/ 无作为资源：https://www.wuzuowei.net/ 淘小众：http://taoxiaozhong.com/ 亦是美：http://www.yishimei.cn/]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle(一)]]></title>
    <url>%2F2018%2F12%2F03%2FOracle(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[你是九月的梦中浓冬，而我躲在梦里不敢见你。 程佳乐-&lt;未梦及半&gt; SQL的分类: DDL:数据定义语言: Create,Drop,Alter DCL:数据控制语言: Grant,if... DML: 数据操纵语言: insert,update,delete... DQL: 数据查询语言: select DDL及DCL语句:12345678910111213141516171819-- 创建表空间create tablespace waterboss --表空间名datafile 'c:\waterboss.dbf' --数据文件存放位置size 100M --初始大小AUTOEXTEND ON NEXT 10M; --自动增长大小-- 验证表空间select * from DBA_DATA_FILES; select * from DBA_TABLESPACES;-- 创建用户create user wateruser --用户名identified by itcast --密码default tablespace waterboss; --默认表空间-- 授权grant dba to wateruser; --授予dba级别的权限-- 验证用户select * from dba_users; DDL及DCL语句:1234567891011121314--建表语句create table t_owners( id number primary key, name varchar2(30), addressid number, housenumber varchar2(30), watermeter varchar2(30), adddate date, ownertypeid number);--查看当前用户下的所有表：select * from user_tables; 数据增删改语句:123456789101112131415161718192021222324252627282930313233343536--插入语句insert into T_OWNERTYPE (ID,NAME) VALUES (1,'居民');select * from T_OWNERTYPE;insert into T_OWNERS VALUES (1,'张三丰',1,'1-1','123456',sysdate,1 );select * from T_OWNERS;--追加两个字段ALTER TABLE T_OWNERS ADD(REMARK VARCHAR2(20),OUTDATE DATE)--重命名表ALTER TABLE t_owners RENAME TO t_owner2--修改语句update T_OWNERS set adddate=adddate-3 where id=1;--修改字段名语法：ALTER TABLE 表名称 RENAME COLUMN 原列名 TO 新列名--修改两个字段ALTER TABLE T_OWNERS MODIFY(REMARK CHAR(20),OUTDATE TIMESTAMP)--删除数据delete from T_OWNERS where id=1;--删除表truncate table T_OWNERTYPE删除字段名--删除一个字段ALTER TABLE 表名称 DROP COLUMN 列名--删除多个字段ALTER TABLE 表名称 DROP (列名 1,列名 2...) 数据类型： 数据类型： 字符型（ 1） CHAR : 固定长度的字符类型，最多存储 2000 个字节 （ 2） VARCHAR2 :可变长度的字符类型，最多存储 4000 个字节 （ 3） LONG : 大文本类型。 最大可以存储 2 个 G 数值型NUMBER : 数值类型 例如： NUMBER(5) 最大可以存的数为 99999 NUMBER(5,2) 最大可以存的数为 999.99 日期型（ 1） DATE：日期时间型，精确到秒 （ 2） TIMESTAMP：精确到秒的小数点后 9 位 二进制型（大数据类型）（ 1） CLOB : 存储字符,最大可以存 4 个 G （ 2） BLOB：存储图像、声音、 视频等二进制数据,最多可以存 4 个 G sqlplus命令： 12sqlplus 用户名/密码@服务器地址及端口号/全局数据库名例：sqlplus system/12345@192.168.80.10:1521/orcl 删除的区别: delete 删除的数据可以rollback. delete 删除可能产生碎片，并且不释放空间. truncate 是先摧毁表结构，再重构表结构. delete和truncate都不改表结构，要把表也删除，使用drop table. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157--练习数据库建表语句--建立价格区间表create table t_pricetable(id number primary key,price number(10,2),ownertypeid number,minnum number,maxnum number);--业主类型create table t_ownertype(id number primary key,name varchar2(38));--业主表create table t_owners(id number primary key,name varchar2(38),addressid number,housenumber varchar2(30),watermeter varchar2(30),adddate date,ownertypeid number);--区域表create table t_area(id number,name varchar2(30));--收费员表create table t_operator(id number,name varchar2(38));--地址表create table t_address(id number primary key,name varchar2(100),areaid number,operatorid number);--账务表--create table t_account (id number primary key,owneruuid number,ownertype number,areaid number,year char(4),month char(2),num0 number,num1 number,usenum number,meteruser number,meterdate date,money number(10,2),isfee char(1),feedate date,feeuser number);create sequence seq_account;--业主类型insert into t_ownertype values(1,'居民');insert into t_ownertype values(2,'行政事业单位');insert into t_ownertype values(3,'商业');--地址信息--insert into t_address values( 1,'明兴花园',1,1);insert into t_address values( 2,'鑫源秋墅',1,1);insert into t_address values( 3,'华龙苑南里小区',2,2);insert into t_address values( 4,'河畔花园',2,2);insert into t_address values( 5,'霍营',2,2);insert into t_address values( 6,'回龙观东大街',3,2);insert into t_address values( 7,'西二旗',3,2);--业主信息insert into t_owners values(1,'范冰',1,'1-1','30406',to_date('2015-04-12','yyyy-MM-dd'),1 );insert into t_owners values(2,'王强',1,'1-2','30407',to_date('2015-02-14','yyyy-MM-dd'),1 );insert into t_owners values(3,'马腾',1,'1-3','30408',to_date('2015-03-18','yyyy-MM-dd'),1 );insert into t_owners values(4,'林小玲',2,'2-4','30409',to_date('2015-06-15','yyyy-MM-dd'),1 );insert into t_owners values(5,'刘华',2,'2-5','30410',to_date('2013-09-11','yyyy-MM-dd'),1 );insert into t_owners values(6,'刘东',2,'2-2','30411',to_date('2014-09-11','yyyy-MM-dd'),1 );insert into t_owners values(7,'周健',3,'2-5','30433',to_date('2016-09-11','yyyy-MM-dd'),1 );insert into t_owners values(8,'张哲',4,'2-2','30455',to_date('2016-09-11','yyyy-MM-dd'),1 );insert into t_owners values(9,'昌平区中西医结合医院',5,'2-2','30422',to_date('2016-10-11','yyyy-MM-dd'),2 );insert into t_owners values(10,'美廉美超市',5,'4-2','30423',to_date('2016-10-12','yyyy-MM-dd'),3 );--操作员insert into t_operator values(1,'马小云');insert into t_operator values(2,'李翠花');--地区--insert into t_area values(1,'海淀');insert into t_area values(2,'昌平');insert into t_area values(3,'西城');insert into t_area values(4,'东城');insert into t_area values(5,'朝阳');insert into t_area values(6,'玄武');--价格表--insert into t_pricetable values(1,2.45,1,0,5);insert into t_pricetable values(2,3.45,1,5,10);insert into t_pricetable values(3,4.45,1,10,null);insert into t_pricetable values(4,3.87,2,0,5);insert into t_pricetable values(5,4.87,2,5,10);insert into t_pricetable values(6,5.87,2,10,null);insert into t_pricetable values(7,4.36,3,0,5);insert into t_pricetable values(8,5.36,3,5,10);insert into t_pricetable values(9,6.36,3,10,null);--账务表--insert into t_account values( seq_account.nextval,1,1,1,'2012','01',30203,50123,0,1,sysdate,34.51,'1',to_date('2012-02-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','02',50123,60303,0,1,sysdate,23.43,'1',to_date('2012-03-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','03',60303,74111,0,1,sysdate,45.34,'1',to_date('2012-04-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','04',74111,77012,0,1,sysdate,52.54,'1',to_date('2012-05-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','05',77012,79031,0,1,sysdate,54.66,'1',to_date('2012-06-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','06',79031,80201,0,1,sysdate,76.45,'1',to_date('2012-07-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','07',80201,88331,0,1,sysdate,65.65,'1',to_date('2012-08-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','08',88331,89123,0,1,sysdate,55.67,'1',to_date('2012-09-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','09',89123,90122,0,1,sysdate,112.54,'1',to_date('2012-10-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','10',90122,93911,0,1,sysdate,76.21,'1',to_date('2012-11-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','11',93911,95012,0,1,sysdate,76.25,'1',to_date('2012-12-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,1,1,1,'2012','12',95012,99081,0,1,sysdate,44.51,'1',to_date('2013-01-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','01',30334,50433,0,1,sysdate,34.51,'1',to_date('2013-02-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','02',50433,60765,0,1,sysdate,23.43,'1',to_date('2013-03-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','03',60765,74155,0,1,sysdate,45.34,'1',to_date('2013-04-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','04',74155,77099,0,1,sysdate,52.54,'1',to_date('2013-05-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','05',77099,79076,0,1,sysdate,54.66,'1',to_date('2013-06-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','06',79076,80287,0,1,sysdate,76.45,'1',to_date('2013-07-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','07',80287,88432,0,1,sysdate,65.65,'1',to_date('2013-08-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','08',88432,89765,0,1,sysdate,55.67,'1',to_date('2013-09-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','09',89765,90567,0,1,sysdate,112.54,'1',to_date('2013-10-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','10',90567,93932,0,1,sysdate,76.21,'1',to_date('2013-11-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','11',93932,95076,0,1,sysdate,76.25,'1',to_date('2013-12-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,2,1,3,'2012','12',95076,99324,0,1,sysdate,44.51,'1',to_date('2014-01-14','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,100,1,3,'2012','12',95076,99324,0,1,sysdate,44.51,'1',to_date('2014-01-01','yyyy-MM-dd'),2 );insert into t_account values( seq_account.nextval,101,1,3,'2012','12',95076,99324,0,1,sysdate,44.51,'1',to_date('2015-01-01','yyyy-MM-dd'),2 );update t_account set usenum=num1-num0;update t_account set money=usenum*2.45;commit;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next6.5主题配置优化]]></title>
    <url>%2F2018%2F12%2F03%2FHexo-Next6-5%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[年年是记忆，来日也可期。 RainyDay-&lt;徐秉龙&gt; 基于Next 6.5版本，网上有很多Next主题配置优化的教程，查找下来感觉比较杂乱，因此总结一些自己所使用的。 1.Next底部图标设置将底部的图标设置为动态红心效果。 2.实现点击出现桃心效果在/themes/next/source/js/src下新建文件 clicklove.js ，接着把如下的代码拷贝粘贴到 clicklove.js 文件中。 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes\next\layout\_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt; 3.修改文章内链接文本样式修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 4.修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 5.在每篇文章末尾统一添加“本文结束”标记在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下代码（post-footer之前两个DIV）： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开next主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag:enabled: true 6.主页文章添加阴影效果打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 7.动态背景进入theme/next目录，执行命令： 1git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 将主题配置文件_config.yml中的canvas_nest: false改为canvas_nest: true生效。 8.添加搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑根配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑Next主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 9.文章置顶在博客根目录下执行： 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，插入如下代码： 12345&#123;% if post.top %&#125; &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125; 然后在需要置顶的文章的Front-matter中加上top: true即可. 10.添加顶部加载条和返回顶部显示百分比 11.代码复制功能 12.添加宠物博客根目录安装插件： 1npm install --save hexo-helper-live2d 下载模型，模型名称可以到这里参考，一些模型的预览可以在这里。 1npm install live2d-widget-model-haruto //我使用的这个 在 hexo 根路径下的 _config.yml中添加参数： 1234567891011121314live2d: enable: true #启用 scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-wanko #模型名称 display: #位置和大小 position: right width: 150 height: 300 mobile: #手机端是否显示 show: true 效果如下： 13.添加音乐第一种方法直接网易云生成外链，放在layout/_macro/sidebar.swig 文件下: 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=490106148&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; //auto为1，自动播放 效果如下： 第二种方式，根目录安装插件： 1npm install hexo-tag-aplayer --save 文章中的写法： 1&#123;% aplayer "歌曲名" "歌手名" "https://什么什么什么.mp3" "https://封面图.jpg" "lrc:https://歌词.lrc" %&#125; var ap = new APlayer({ element: document.getElementById("aplayer-YlIsrMTn"), narrow: false, autoplay: false, showlrc: 3, music: { title: "妄越", author: "代鑫", url: "https://ilibing.nos-eastchina1.126.net/music/%E5%A6%84%E8%B6%8A%20-%20%E4%BB%A3%E9%91%AB%20.mp3", pic: "http://p2.music.126.net/MRZDcno4qbfqNb0g03OaFQ==/109951163049991008.jpg", lrc: "https://ilibing.nos-eastchina1.126.net/music/%E5%A6%84%E8%B6%8A%20-%20%E4%BB%A3%E9%91%AB.lrc" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 另外可以支持歌单： 123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; "narrow": false, // （可选）播放器袖珍风格 "autoplay": true, // （可选) 自动播放，移动端浏览器暂时不支持此功能 "mode": "random", // （可选）曲目循环类型，有 'random'（随机播放）, 'single' (单曲播放), 'circulation' (循环播放), 'order' (列表播放)， 默认：'circulation' "showlrc": 3, // （可选）歌词显示配置项，可选项有：1,2,3 "mutex": true,// （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 "theme": "#e6d0b2", // （可选）播放器风格色彩设置，默认：#b7daff "preload": "metadata", // （可选）音乐文件预载入模式，可选项： 'none' 'metadata' 'auto', 默认: 'auto' "listmaxheight": "513px", // (可选) 该播放列表的最大长度 "music": [ &#123; "title": "CoCo", "author": "Jeff Williams", "url": "caffeine.mp3", "pic": "caffeine.jpeg", "lrc": "caffeine.txt" &#125;, &#123; "title": "アイロニ", "author": "鹿乃", "url": "irony.mp3", "pic": "irony.jpg" &#125; ]&#125;&#123;% endaplayerlist %&#125; 以上添加音乐的方法过于复杂： 使用MeingJS支持(可参考官方文档)，在根目录配置文件_config.yml下加入： 12aplayer: meting: true 之后文章要插入的地方使用这种格式(随意选用一种)： 123456第一种：&lt;!-- Simple example (id, server, type) --&gt;&#123;% meting "60198" "netease" "playlist" %&#125;第二种：&lt;!-- Advanced example --&gt;&#123;% meting "60198" "netease" "playlist" "autoplay" "mutex:false" "listmaxheight:340px" "preload:none" "theme:#ad7a86"%&#125; 选项 默认 描述 ID 需要 歌曲ID /播放列表ID /专辑ID /搜索关键字 server 需要 音乐平台：netease，tencent，kugou，xiami，baidu type 需要 song，playlist，album，search，artist fixed false 启用固定模式 mini false 启用迷你模式 loop all 播放器循环播放，值：’all’，’one’，’none’ order list 顺序，值：’列表’，’随机’ volume 0.7 默认音量，注意播放器将记住用户设置，默认音量将在用户自行设置音量后无效 lrctype 0 歌词类型 listfolded false 指示列表是否应首先折叠 autoplay false 自动播放歌曲，移动浏览器不支持 mutex true 当该玩家玩时，暂停其他玩家 listmaxheight 340px 播放列表的最大高度 preload auto 载入音乐的方式，可以是none，metadata，auto storagename metingjs 存储播放器设置的LocalStorage键 theme #ad7a86 主题色 更多优化可参考博客教程： 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene学习入门]]></title>
    <url>%2F2018%2F12%2F02%2FLucene%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[你如星辰入海，倾万鲸成宇宙。 尚东峰-&lt;鱼辞&gt; 一.搜索引擎原理. 二.什么是lucene1234Lucene是一套用于全文检索和搜寻的开源程序库，由Apache软件基金会支持和提供.Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具.Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品.官网：http://lucene.apache.org/ 1.什么是全文检索.如何实现.计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式.通过分词. 对要搜索的内容先创建索引,然后再通过索引进行搜索的过程. 倒排索引: 又叫反向索引,以字或词为关键字进行索引，表中关键字所对应的记录表项，记录了出现这个字或词的所有文档，每一个表项记录该文档的ID和关键字在该文档中出现的位置情况. 总结：对文档（数据）中每一个词都做索引. 2.索引和搜索的流程 12341、绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：确定原始内容即要搜索的内容--&gt;采集文档--&gt;创建文档对象--&gt;分析文档--&gt;索引文档.2、红色表示搜索过程，从索引库中搜索内容，搜索过程包括：用户通过搜索界面--&gt;创建查询--&gt;执行搜索，从索引库搜索--&gt;渲染搜索结果. 二.Lucene的基本使用使用Lucene的API来实现对索引的增（创建索引）、删（删除索引）、改（修改索引）、查（搜索数据） 1.新建一个普通的maven项目.2.导入pom相关依赖.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//(出现红叉记得maven/update project)&lt;dependencies&gt; &lt;!-- Junit单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lucene核心库 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;version&gt;4.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Lucene的查询解析器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt; &lt;version&gt;4.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lucene的默认分词器库 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt; &lt;version&gt;4.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lucene的高亮显示 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-highlighter&lt;/artifactId&gt; &lt;version&gt;4.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- io流 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 3.创建索引库123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Lucene &#123; @Test public void createIndex() throws Exception &#123; // 创建目录对象，指定索引库的存放位置；FSDirectory文件系统；RAMDirectory内存 // 索引库保存到内存中,一般不用 // Directory directory=new RAMDirectory(); // 保存到磁盘 Directory directory = FSDirectory.open(new File("D:\\lucene\\index")); // 创建分词器对象 Analyzer analyzer = new StandardAnalyzer(); // 创建索引写入器配置对象，第一个参数版本VerSion.LATEST,第一个参数分词器 IndexWriterConfig conf = new IndexWriterConfig(Version.LATEST, analyzer); // 创建一个索引写入器(IndexWriter),参数1:索引库存放的路径,参数2:配置信息,其中包括分词器对象. IndexWriter indexWriter = new IndexWriter(directory, conf); // 获得原始文档,使用io流读取文本文件 File docPath=new File("D:\\lucene\\searchsource"); for (File f : docPath.listFiles()) &#123; //取文件名 String fileName = f.getName(); //取文件路径 String filePath = f.getPath(); //文件内容 String fileContent = FileUtils.readFileToString(f); //文件大小 long fileSize = FileUtils.sizeOf(f); // 创建文档对象 Document document = new Document(); //创建域 //参数1：域的名称 参数2：域的内容 参数3：是否存储 TextField fileNameField = new TextField("name", fileName, Store.YES); StoredField filePathField = new StoredField("path", filePath); TextField fileContentField = new TextField("content", fileContent, Store.NO); LongField fileSizeField = new LongField("size", fileSize, Store.YES); //5、向文档中添加域(term) document.add(fileNameField); document.add(filePathField); document.add(fileContentField); document.add(fileSizeField); //6、把文档对象写入索引库 indexWriter.addDocument(document); &#125; // 关闭IndexWriter对象 indexWriter.close(); &#125;&#125; 运行创建索引库成功: 4.使用luke工具查看索引文件运行start.bat打开. 文档列表: 搜索页面: 5.查询索引器1234567891011121314151617181920212223242526272829303132//查询索引库 @Test public void searchIndex() throws Exception &#123; //1指定索引库存放的位置 Directory directory = FSDirectory.open(new File("D:\\lucene\\index")); //2使用IndexReader对象打开索引库 IndexReader indexReader = DirectoryReader.open(directory); //3创建一个IndexSearcher对象，构造方法需要一个indexReader对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); //4创建一个查询对象,需要指定查询域及要查询的关键字。 //term的参数1：要搜索的域, 参数2：搜索的关键字 Query query = new TermQuery(new Term("name", "apache")); //参数1：查询条件, 参数2：查询结果返回的最大值 //5取查询结果 TopDocs topDocs = indexSearcher.search(query, 10); //取查询结果总记录数 System.out.println("查询结果总记录数：" + topDocs.totalHits); //6遍历查询结果并打印. for (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123; //取文档id int id = scoreDoc.doc; //从索引库中取文档对象 Document document = indexSearcher.doc(id); //取属性 System.out.println(document.get("name")); System.out.println(document.get("size")); System.out.println(document.get("content")); System.out.println(document.get("path")); &#125; //7关闭IndexReader对象 indexReader.close(); &#125; 6.IK中文分词器优点: 中文分词更专业,可以扩展自定义词库(扩展词典和停用词典). 12345678910&lt;!-- 引入IK分词器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.janeluo&lt;/groupId&gt; &lt;artifactId&gt;ikanalyzer&lt;/artifactId&gt; &lt;version&gt;2012_u6&lt;/version&gt; &lt;/dependency&gt;//将自定义词库的三个配置文件放到classpath下.//exit.dic 扩展词典//stopword.dic 停用词典//IKAnalyzer ik配置文件 12345678910111213141516171819202122232425262728293031//查看IK分析器的分词效果 @Test public void testAnanlyzer() throws Exception &#123; //创建一个分析器对象 //标准分词器 //Analyzer analyzer = new StandardAnalyzer(); //Analyzer analyzer = new CJKAnalyzer(); //智能中文分词器 //Analyzer analyzer = new SmartChineseAnalyzer(); //IK中文分词器 Analyzer analyzer = new IKAnalyzer(); //从分析器对象中获得tokenStream对象 //参数1：域的名称，可以为null或者"" //参数2：要分析的文本内容 TokenStream tokenStream = analyzer.tokenStream("", "设置一个引用，引用可以有多重类型，可以时候关键词的引用、偏移量的引用"); //设置一个引用，引用可以有多重类型，可以时候关键词的引用、偏移量的引用 CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class); //偏移量 OffsetAttribute offsetAttribute = tokenStream.addAttribute(OffsetAttribute.class); //调用tokenStream的reset方法 tokenStream.reset(); //使用while循环变量单词列表 while (tokenStream.incrementToken()) &#123; System.out.println("start-&gt;" + offsetAttribute.startOffset()); //打印单词 System.out.println(charTermAttribute); System.out.println("end-&gt;" + offsetAttribute.endOffset()); &#125; //关闭tokenStream tokenStream.close(); &#125; 7.添加文档1234567891011121314151617181920//添加文档 @Test public void addDocument() throws Exception &#123; Directory directory = FSDirectory.open(new File("D:\\lucene\\index")); Analyzer analyzer = new IKAnalyzer(); //参数1：lucene的版本号，第二个参数：分析器对象 IndexWriterConfig conf = new IndexWriterConfig(Version.LATEST, analyzer); IndexWriter indexWriter = new IndexWriter(directory, conf); //创建Document对象 Document document = new Document(); //创建域 TextField FileNameField = new TextField("name", "测试文件.txt", Store.YES); StoredField FilepathField = new StoredField("path", "D:\\lucene\\测试文件.txt"); document.add(FileNameField); document.add(FilepathField); //写入索引库 indexWriter.addDocument(document); //关闭资源 indexWriter.close(); &#125; 8.删除文档1234567891011121314151617181920212223242526272829public IndexWriter getIndexWriter() throws Exception &#123; Directory directory = FSDirectory.open(new File("D:\\lucene\\index")); Analyzer analyzer = new IKAnalyzer(); //参数1：lucene的版本号，第二个参数：分析器对象 IndexWriterConfig conf = new IndexWriterConfig(Version.LATEST, analyzer); IndexWriter indexWriter = new IndexWriter(directory, conf); return indexWriter; &#125;//删除全部文档(慎用!!!) @Test public void deleteAllDocument() throws Exception &#123; //获得IndexWriter对象 IndexWriter indexWriter = this.getIndexWriter(); //调用删除方法删除索引库 indexWriter.deleteAll(); //关闭资源 indexWriter.close(); &#125;//根据查询条件删除 @Test public void deleteDocumentByQuery() throws Exception &#123; IndexWriter indexWriter = this.getIndexWriter(); //指定查询条件 Query query = new TermQuery(new Term("name", "apache")); //删除文档 indexWriter.deleteDocuments(query); //关闭资源 indexWriter.close(); &#125; 9.更新索引库12345678910111213//更新索引库(本质:先删除后添加) @Test public void updateDocument() throws Exception &#123; IndexWriter indexWriter = this.getIndexWriter(); //创建一个新的文档对象 Document document = new Document(); document.add(new TextField("name", "更新后的文档", Store.YES)); document.add(new TextField("content", "更新后的文档内容", Store.YES)); //term对象：指定要删除域及要删除的关键词，先根据term查询，把查询结果删除，然后追加一个新的文档。 indexWriter.updateDocument(new Term("name", "spring"), document); //关闭资源 indexWriter.close(); &#125; 10.Query子类查询-查询所有文档1234567891011121314151617181920212223242526272829303132//查询所有文档public class SearchIndex &#123; @Test public void testMatchAllDocsQuery() throws Exception &#123; //指定索引库存放的路径 Directory directory = FSDirectory.open(new File("D:\\lucene\\index")); //创建一个IndexReader对象 IndexReader indexReader = DirectoryReader.open(directory); //创建IndexSearcher对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); //创建一个Query对象,匹配所有文档查询 Query query = new MatchAllDocsQuery(); System.out.println(query); //查询索引库 TopDocs topDocs = indexSearcher.search(query, 100); ScoreDoc[] scoreDocs = topDocs.scoreDocs; System.out.println("查询结果总记录数：" + topDocs.totalHits); //遍历查询结果 for (ScoreDoc scoreDoc : scoreDocs) &#123; int docId = scoreDoc.doc; //通过id查询文档对象 Document document = indexSearcher.doc(docId); //取属性 System.out.println(document.get("name")); System.out.println(document.get("size")); System.out.println(document.get("content")); System.out.println(document.get("path")); &#125; //关闭索引库 indexReader.close(); &#125;&#125; 1234567891011121314151617181920212223242526//提取重复代码private IndexSearcher getIndexSearcher() throws Exception &#123; //指定索引库存放的路径 Directory directory = FSDirectory.open(new File("D:\\lucene\\index")); //创建一个IndexReader对象 IndexReader indexReader = DirectoryReader.open(directory); //创建IndexSearcher对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); return indexSearcher; &#125; private void printResult(IndexSearcher indexSearcher, Query query) throws Exception &#123; //查询索引库 TopDocs topDocs = indexSearcher.search(query, 100); ScoreDoc[] scoreDocs = topDocs.scoreDocs; System.out.println("查询结果总记录数：" + topDocs.totalHits); //遍历查询结果 for (ScoreDoc scoreDoc : scoreDocs) &#123; int docId = scoreDoc.doc; //通过id查询文档对象 Document document = indexSearcher.doc(docId); //取属性 System.out.println(document.get("name")); System.out.println(document.get("size")); System.out.println(document.get("content")); System.out.println(document.get("path")); &#125; 11.数值范围查询123456789@Test public void testNumericRangeQuery() throws Exception &#123; //创建一个数值范围查询对象 //参数1：要查询的域 参数2：最小值 参数3：最大值 参数4：是否包含最小值 参数5：是否包含最大值 Query query = NumericRangeQuery.newLongRange("size", 1000l, 10000l, false, true); System.out.println(query); //打印结果 printResult(getIndexSearcher(), query); &#125; 12.组合条件查询1234567891011121314151617181920//Occur.MUST：必须满足此条件，相当于and//Occur.SHOULD：应该满足，但是不满足也可以，相当于or//Occur.MUST_NOT：必须不满足。相当于not//组合条件查询 @Test public void testBooleanQuery() throws Exception &#123; //创建一个BooleanQuery对象 BooleanQuery query = new BooleanQuery(); //创建子查询，文件大于1000小于10000 //Query query1 = NumericRangeQuery.newLongRange("size", 1000l, 10000l, true, true); Query query1 = new TermQuery(new Term("name", "lucene")); //文件名中包含mybatis关键字 Query query2 = new TermQuery(new Term("name", "apache")); //添加到BooleanQuery对象中 query.add(query1, Occur.MUST); query.add(query2, Occur.MUST_NOT); System.out.println(query); //执行查询 printResult(getIndexSearcher(), query); &#125; 13.使用Queryparse查询通过QueryParser也可以创建Query，QueryParser提供一个Parse方法，此方法可以直接根据查询语法来查询。Query对象执行的查询语法可通过System.out.println(query);查询。需要使用到分析器。建议创建索引时使用的分析器和查询索引时使用的分析器要一致。 1234567891011 @Test public void testQueryParser() throws Exception &#123; //创建一个QueryParser对象。参数1：默认搜索域 参数2：分析器对象。 QueryParser queryParser = new QueryParser("content", new IKAnalyzer()); //调用parse方法可以获得一个Query对象 //参数：要查询的内容，可以是一句话。先分词在查询 Query query = queryParser.parse("mybatis is a apache project");// Query query = queryParser.parse("name:lucene OR name:apache"); System.out.println(query); printResult(getIndexSearcher(), query); &#125; 14.Lucene查询语法123456789101112131415161718192021222324251、基础的查询语法，关键词查询：域名+“：”+搜索的关键字例如：content:java2、范围查询域名+“:”+[最小值 TO 最大值]例如：size:[1 TO 1000]范围查询在lucene中不支持数值类型，支持字符串类型。在solr中支持数值类型。3、组合条件查询1）+条件1 +条件2：两个条件之间是并且的关系and例如：+filename:apache +content:apache2）+条件1 条件2：必须满足第一个条件，应该满足第二个条件例如：+filename:apache content:apache3）条件1 条件2：两个条件满足其一即可。例如：filename:apache content:apache4）-条件1 条件2：必须不满足条件1，要满足条件2例如：-filename:apache content:apacheOccur.MUST 查询条件必须满足，相当于and +（加号）Occur.SHOULD 查询条件可选，相当于or 空（不用符号）Occur.MUST_NOT 查询条件不能满足，相当于not非 -（减号）第二种写法：条件1 AND 条件2条件1 OR 条件2条件1 NOT 条件2 15.指定多个默认搜索域123456789@Testpublic void testMultiFileQueryParser() throws Exception &#123; //指定默认搜索域 String[] fields =&#123;"name", "content"&#125;; MultiFieldQueryParser queryParser = new MultiFieldQueryParser(fields, new IKAnalyzer()); Query query = queryParser.parse("mybatis is a apache project"); System.out.println(query); printResult(getIndexSearcher(), query);&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2F2018%2F12%2F02%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[一见如故的人还等候在远方里，请你向前去。 情桑-&lt;致，孤勇如你&gt; 什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本博客即使用hexo+github搭建而成，在此记录一下过程。 搭建环境： Win10x64位，hexo 3.8.0,Node 8.11.3,Git 2.18.0 安装Hexo前提先安装两个软件，点击官网安装Node.js和Git，默认安装即可。Git安装完成后鼠标右击桌面会出现两个选项图标，点击框中那个，这个以后会经常用到。 1.新建一个文件夹取名，比如我的G:\HexoBlog,右键进入Git Bash,输入命令。 1npm install -g hexo-cli //出现以下即安装成功 安装 Hexo 完成后，继续依次执行下列命令。 123hexo init blog //这个过程会受网络限制，耐心等待。cd blog npm install 之后执行以下命令，以后必用： 1234hexo clean //清除缓存，这里不执行hexo g //重新生成(执行)hexo s //本地服务浏览（执行）hexo d //推送至Github,这里不执行 至此，可打开浏览器输入：localhost:4000,本地查看博客效果，按ctrl+c停止。 下载主题-Next(官网)1.安装 Git 部署插件： 1npm install hexo-deployer-git --save 2.下载Next,参考安装包，或直接克隆 1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题123在 Hexo 中有2份主要的配置文件，其名称都是_config.yml。 其中，一份位于博客根目录下，主要包含Hexo本身的配置；另一份位于themes/next/目录下，用于配置主题相关的选项。打开themes/next/下的_config.yml,查找scheme，可以看到四种不同的风格。去掉#注释，即启用对应的scheme，博主采用Gemini主题，大家可以依次测试效果，选择自己喜欢的scheme。打开根目录下的_config.yml，查找theme字段，将字段改为theme: next(冒号:之后要有空格分隔，否则无效) 之后通过hexo g和hexo s，再在浏览器中访问localhost:4000即可本地预览主题效果。 主题基础配置设置过程中，可运行在本地查看，步骤跟之前一样(注意所有的：后面都要空一格!!!)。 1.设置菜单打开themes/next/下的_config.yml，查找menu，去掉#注释即可显示对应的菜单项。 2.设置网站基本信息和语言打开根目录下的_config.yml，找到Site如下设置。 3.设置个人信息打开themes/next/下的_config.yml，找到social如下设置。 4.设置头像进入themes/next/source/images下，找到avatar.gif，放入一张同样大小的图片替换名字。之后打开themes/next/下的_config.yml，找到avatar如下设置。 创建github仓库经过以上简单的配置，已经基本有个大概了，可以在本地查看效果，别的优化后面介绍，接下来结合github来搭建。 1.注册github账号。（略，自行百度。） 2.创建一个新仓库。 3.填写仓库信息。 4.建好仓库之后，在仓库界面选择仓库名称下面一行选项中的”settings”进入到仓库的设置界面中。 5.点击箭头选择一个主题，就可以通过地址在网络上访问了。 6.选择仓库地址，打开根目录下的_config.yml进行设置。 发布到github仓库安装git部署插件npm install hexo-deployer-git --save。 生成SSH秘钥 设置全局用户名和邮箱。 创建一个 SSH key 。在命令行依次（即Git Bash）输入以下命令， 回车三下即可： 123$ ssh-keygen -t rsa -C &quot;邮箱地址&quot;$ eval &quot;(ssh-agent -s)&quot;$ ssh-add ~/.ssh/id_rsa 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到github上setting下面的SSH即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 2.等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io至此，你的Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io教程至此，便能搭建一个最基础的博客。 个性化配置请移步：Next6.5主题配置]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
